# 01.面向对象

## 1. OOD 三大特性

### 1.1 封装 (encapsulation)

- Class

- Object

- ```java
  // Class
  class Animal{}
  
  // Instance
  Animal a = new Animal();
  
// 封装：访问控制符(private, etc.)
  class Employee{
      private String name;
      private float salary;
      private int level;
      
      public void raiseSalary(float amount);
      public void printName();
      public void promoteLevel();
      
      // 只读
      public String getName();
  }
  ```
  
  - **private**：`Employee{}` 类的外部，是不可能访问到 `name` 这个属性的
  - **public**：外部函数可以**访问函数**来获取 name

### 1.2 继承 (inherit)

- **a** is a **A**

- 猫猫是一个动物 

- ```java
  // 父类
  class Animal{
      protected String name;
      public int id;
      private String privacy;
      
      public void description(){
          System.out.println("This is a general animal object");
      }
  }
  
  // 子类
  class Dog extends Animal{
      
  }
  
  // main
  Dog dog = new Dog();
  dog.description(); // 继承父类中的函数
  ```

  - 子类：继承父类中所有 **非 private** 的属性、方法
  - **protected**：只有**继承父类的子类**，才可以访问

- ```java
  // 父类
  class Animal{
      protected String name;
      public int id;
      private String privacy;
  
      public void description(){
          System.out.println("This is a general animal object");
      }
  }
  
  // 子类
  class Dog extends Animal{
      // override
      public void description(){
          System.out.println("这是一个 Dog 子类");
          System.out.println("Name ->" + name);
          System.out.println("Id ->" + id);
          System.out.println("Privacy ->" + privacy); // THIS IS WRONG !!!
      }
      
      // overload
      public void description(String type){
          System.out.println("这是一个" + type);
      }
  }
  
  // main
  Dog dog = new Dog();
  dog.description(); 
  ```

  - **override**：重写父类函数
  - **overload**：重载；函数参数列表不一样

- ```java
  // 父类
  class Animal{
      protected String name;
      public int id;
      private String privacy;
  
      public void description(){
          System.out.println("This is a general animal object");
      }
  }
  
  // 子类
  class Dog extends Animal{
      // override
      public void description(){
          super(); // This will call Base class's description
      }
  }
  ```

  - **super**：调用父类中的同名函数
  - **final**：当前 class 不能被继承

- ```java
  // 父类
  abstract class Animal{
      protected String name;
      public int id;
      private String privacy;
  
      public void description(){
          System.out.println("This is a general animal object");
      }
      
      // 抽象函数: 没有默认实现
      public abstract void makeSound();
  }
  
  // 子类1
  class Dog extends Animal{
      // 子类：必须提供抽象函数 makeSound 的实现
      public void makeSound(){
          System.out.println(" woof! ")
      }
      
      // override
      public void description(){
          super(); // This will call Base class's description
      }
  }
  
  // 子类2
  class Cat extends Animal{
      public void makeSound(){
          System.out.println(" Meeow! ")
      }
  }
  
  // 抽象类：继承 Animal
  abstract class Mammal extends Animal{
      // 另一个抽象类，无法有实现的 makeSound
  }
  
  Animal animal = new Animal(); // THIS IS WRONG
  Animal animal = new Dog(); // THIS IS CORRECT
  ```

  - **抽象类**：不能初始化 `new Animal()`，可以用子类初始化
  - **抽象函数**：子类必须**提供抽象函数 makeSound 的实现**，否则必须定义为 **abstract class**

- ### Interface

  - contract 合同：必须满足（实现）接口中的函数

  - interface 中的函数都是**抽象函数**，所以必须**实现所有函数**

    - ```java
      interface Service{
          // No Constructor
          public void serve();
          public void retire();
      }
      
      class Dog implements Service{
          public void serve(){
              // dog in service
          }
          
          public void retire(){
              // dog retire from service
          }
      }
      ```

  - 类：只有一个父类 (Base)，但是可以实现多个接口（接多个合同）

    - ```java
      interface Service{
          // No Constructor
          public void serve();
          public void retire();
      }
      
      interface Circus{
          public void perform();
      }
      
      // 父类
      class Animal{
          protected String name;
          public int id;
          private String privacy;
          
          public void description(){
              System.out.println("This is a general animal object");
          }
      }
      
      // 子类
      class Dog extends Animal implements Service, Circus{
          public void serve(){
              // dog in service
          }
          
          public void retire(){
              // dog retire from service
          }
          
          public void perform(){
              // dog perform in circus
          }
      }
      ```

### 1.3 多态 (Ploymorphism)

- ```java
  // 父类
  abstract class Animal{
      // 抽象函数: 没有默认实现
      public abstract void makeSound();
  }
  
  // 子类1
  class Dog extends Animal{
      // 子类：必须提供抽象函数 makeSound 的实现
      public void makeSound(){
          System.out.println(" woof! ")
      }
  }
  
  // 子类2
  class Cat extends Animal{
      public void makeSound(){
          System.out.println(" Meeow! ")
      }
  }
  
  Animal animal1 = new Dog();
  Animal animal2 = new Cat();
  
  animal1.makeSound();
  animal2.makeSound();
  ```

- 同一个 `makeSound()`，不同的方法



## 1. S.O.L.I.D原则

### 1.1 Single Responsibility Principle

- 





















































