#### [973. K Closest Points to Origin](https://leetcode-cn.com/problems/k-closest-points-to-origin/)

![image-20220127150531251](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220127150531251.png)

## 1. PriorityQueue

- `PriorityQueue<distance, index>` 最小堆

- `distance - index` 做配对，这样每个 index 都是独特的。可以避免同一个distance，但是点不同的情况

- ```java
  class Solution {
      public int[][] kClosest(int[][] points, int k) {
          // edge condition
          if(points == null || points.length == 0 || points[0] == null || points[0].length == 0){
              return new int[0][0];
          }
  
          // PriorityQueue<distance, index> 最小堆
          Queue<int[]> pq = new PriorityQueue<>((o1, o2) -> {
              return o1[0] - o2[0];
          });
  
          // distance - index 做配对，这样每个 index 都是独特的。可以避免同一个distance，但是点不同的情况
          for(int i = 0; i < points.length; i++){
              int distance = points[i][0] * points[i][0] + points[i][1] * points[i][1];
              pq.offer(new int[]{distance, i});
          }
  
          int[][] result = new int[k][2]; 
  
          for(int i = 0; i < k; i++){
              int[] close = pq.poll();
              result[i] = points[close[1]];
          }       
  
          return result;
      }
  }
  ```

- 

