#### [472. 连接词](https://leetcode-cn.com/problems/concatenated-words/)

![image-20220123183538527](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220123183538527.png)

## 1. 字典树

- ```java
  class Tire{
      boolean isEnd;
      Tire[] children;
  
      public Tire(){
          children = new Tire[26];
          isEnd = false;
      }
  }
  
  class Solution {
  
      Tire tire = new Tire();
  
      public List<String> findAllConcatenatedWordsInADict(String[] words) {
          // 答案集
          List<String> result = new ArrayList<>();
  
          // 字符从短到长排序
          Arrays.sort(words, (o1, o2) -> {
              return o1.length() - o2.length();
          });
  
          // 遍历每个单词
          for(int i = 0; i < words.length; i++){
              // 获取当前字符串
              String word = words[i];
              // 排除空字符串
              if(word.length() == 0){
                  continue;
              }
              // 对每个字符串，新建 visited；记录本字符串中那个 char 已经使用过，防止 dfs 时，字典树已经遍历过的字符，在下一个for循环中又被重复遍历
              boolean[] visited = new boolean[word.length()];
              // 如果找到之前某个word
              if(dfs(word, 0, visited)){
                  result.add(word);
              }
              // 加入字典树
              else{
                  insert(word);
              }
          }
          return result;
      }
  
      public boolean dfs(String word, int start, boolean[] visited){
          // 找到 [连接词]
          if(word.length() == start){
              return true;
          }
          // visited
          if(visited[start]){
              return false;
          }
          // 字典树
          Tire node = tire;
          // dfs
          for(int i = start; i < word.length(); i++){
              char ch = word.charAt(i);
              int index = ch - 'a';
              node = node.children[index];
  
              // 字典树中不存在当前字符串
              if(node == null){
                  return false;
              }
              if(node.isEnd){
                  if(dfs(word, i + 1, visited)){
                      return true;
                  }
              }
          }
          return false;
      }
  
      public void insert(String word){
          Tire node = tire;
          for (int i = 0; i < word.length(); i++) {
              char ch = word.charAt(i);
              int index = ch - 'a';
              if (node.children[index] == null) {
                  node.children[index] = new Tire();
              }
              node = node.children[index];
          }
          node.isEnd = true;
      }
  }
  ```

- 

## 2. DFS - permutation (超时)

- ```java
  // K.Z
  class Solution {
  
      List<String> result = new ArrayList<>();
  
      public List<String> findAllConcatenatedWordsInADict(String[] words) {
          if(words == null || words.length == 0){
              return new ArrayList<>();
          }
  
          StringBuilder sb = new StringBuilder();
  
          dfs(Arrays.asList(words), "", 0);
  
          return result;
      }
  
      public void dfs(List<String> words, String str, int layer){
          if(layer > words.size()){
              return;
          }
          if(words.contains(str) && layer > 1){
              result.add(str);
          }
  
          for(int i = 0; i < words.size(); i++){
              dfs(words, str + words.get(i), layer + 1);
          }
      }
  }
  ```

- 