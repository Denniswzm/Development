#### [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

![image-20211129121622098](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211129121622098.png)

## 1. Priority Queue

- ```java
  class Solution {
      public int[] topKFrequent(int[] nums, int k) {
          // edge condition
          if (nums == null || nums.length == 0) {
              return nums;
          }
  
          // HashMap: record the times of number
          Map<Integer, Integer> map = new HashMap<>();
  
          for (int i = 0; i < nums.length; i++) {
              map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
          }
  
          // priority queue, min
          Queue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
              @Override
              public int compare(Integer o1, Integer o2) {
                  return map.get(o1) - map.get(o2);
              }
          });
  
          // pq <-> map 将每个数字出现的次数，放入 pq，只要有比最小堆顶大的元素，需要加入
          for (Integer num : map.keySet()) {
              // pq 中没填满时，直接加入
              if (pq.size() < k) {
                  pq.add(num);
              }
              // 如果新出现的数字，比 peek 更大
              else if (map.get(pq.peek()) < map.get(num)) {
                  pq.poll();
                  pq.add(num);
              }
          }
  
          // 回写
          int[] result = new int[k];
          for (int i = 0; i < k; i++) {
              result[i] = pq.poll();
          }
          return result;
      }
  }
  ```


