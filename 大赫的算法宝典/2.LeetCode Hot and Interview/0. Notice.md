# 语法注意

- int -> double
  - `Double.valueOf(1)`
  
- 向上取整
  - `Math.ceil(7.0/3.0)`
  - 函数中必须是 Double 类型
  
- 除数为 (double) 0 时，不报错，但是会变为 2147483647
  - `int per = (int) Math.ceil(10.0 / (double) 0);`
  
- 打印数组
  - `System.out.println(Arrays.toString(nums));`
  - `Arrays.toString(iosDailyDownload.toArray())`
  
- 数组截取
  - `Arrays.copyOfRange(result, 0, index)`
  
- List -> Array (String)
  - `List<int[]> merged = new ArrayList<>();`
  - `merged.toArray(new int[merged.size()][]);`
  
- List -> Array (int)
  - `List<Integer> result = new ArrayList<>();`
  - `result.stream().mapToInt(Integer::valueOf).toArray();`
  
- Collection 差集并集交集
  - java中交集使用 `A.retainAll(B)` ,交集的结果在集合A中。
  - 并集使用addAll，`A.addAll(B)` 因为set本身就去重，所有直接全部添加到一个集合中取并集。
  - 差集使用`removeAll`方法，去掉一集合中包含的另一个集合的值。`A.removeAll(B)`
  
- char <---> String
  - `str.toCharArray()`
  - `new String(charArray)`
  
- 数组求和

  - `total = Arrays.stream(w).sum();`

- 随机数

  - ```java
    double random=Math.random();//返回[0,1)随机数
    (int)(Math.random()*6)//返回0-5；随机数
    (int)(Math.random()*6+1)//返回1-6，随机塞子
    ```





# 题型分类

## 1.双指针

### 1.1 朴素二分法：

1. [704. 二分查找](./704. 二分查找)
2. [34. 在排序数组中查找元素的第一个和最后一个位置](./34. 在排序数组中查找元素的第一个和最后一个位置)
3. [702.搜索长度未知的有序数组](https://leetcode-cn.com/problems/search-in-a-sorted-array-of-unknown-size)
4. [153. 寻找旋转排序数组中的最小值](153. 寻找旋转排序数组中的最小值)
5. [154. 寻找旋转排序数组中的最小值 II](154. 寻找旋转排序数组中的最小值 II)
6. [278. 第一个错误的版本](278. 第一个错误的版本)
7. [658. 找到 K 个最接近的元素](658. 找到 K 个最接近的元素)

### 1.2 条件二分法

1. [33. 搜索旋转排序数组](33. 搜索旋转排序数组)
2. [81. 搜索旋转排序数组 II](81. 搜索旋转排序数组 II)
3. [4. 寻找两个正序数组的中位数](4. 寻找两个正序数组的中位数)
4. [74. 搜索二维矩阵](74. 搜索二维矩阵)
5. [162. 寻找峰值](162. 寻找峰值)
6. [302. 包含全部黑色像素的最小矩形](302. 包含全部黑色像素的最小矩形) [MONEY]
7. [852. 山脉数组的峰顶索引](852. 山脉数组的峰顶索引)

### 1.3 答案二分法

1. [875. 爱吃香蕉的珂珂](875. 爱吃香蕉的珂珂)
2. [1283. 使结果不超过阈值的最小除](1283. 使结果不超过阈值的最小除)
3. [69. Sqrt(x)](69. Sqrt(x))

## 2. 多指针

- PriorityQueue 优先队列
  - 找中位数【两个堆】
  - 前 K 个数

### 2.1 数组

1. [912. 排序数组](912. 排序数组)
2. [75. 颜色分类](75. 颜色分类)
3. [26. 删除有序数组中的重复项](26. 删除有序数组中的重复项)
4. [80. 删除有序数组中的重复项 II](80. 删除有序数组中的重复项 II)
5. [88. 合并两个有序数组](88. 合并两个有序数组)
6. [283. 移动零](283. 移动零)
7. [215. 数组中的第K个最大元素](215. 数组中的第K个最大元素)
8. [347. 前 K 个高频元素](347. 前 K 个高频元素)
9. [349. 两个数组的交集](349. 两个数组的交集)
10. [350. 两个数组的交集 II](350. 两个数组的交集 II)
11. [845. 数组中的最长山脉](845. 数组中的最长山脉)
12. [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water)【no】
13. [43. 字符串相乘](43. 字符串相乘)
14. [969. 煎饼排序](969. 煎饼排序)

### 2.2 链表

1. [21. 合并两个有序链表](21. 合并两个有序链表)
2. [86. 分隔链表](86. 分隔链表)
3. [141. 环形链表](141. 环形链表)
4. [160. 相交链表](160. 相交链表)
5. [328. 奇偶链表](328. 奇偶链表)
6. [142. 环形链表 II](142. 环形链表 II)
7. [287. 寻找重复数](287. 寻找重复数)
8. [876. 链表的中间结点](876. 链表的中间结点)

### 2.3 区间

1. [56. 合并区间](56. 合并区间)
2. [57. 插入区间](57. 插入区间)
3. [252. 会议室](https://leetcode-cn.com/problems/meeting-rooms)【Money】
4. [253. 会议室 II](https://leetcode-cn.com/problems/meeting-rooms-ii)【Money】
5. [986. 区间列表的交集](986. 区间列表的交集)
6. [345. 反转字符串中的元音字母](345. 反转字符串中的元音字母)
7. [680. 验证回文字符串 Ⅱ](680. 验证回文字符串 Ⅱ)
8. [125. 验证回文串](125. 验证回文串)

### 2.4 滑动窗口

1. [3. 无重复字符的最长子串](3. 无重复字符的最长子串)
2. [11. 盛最多水的容器](11. 盛最多水的容器)
3. [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring)【难】
4. [209. 长度最小的子数组](209. 长度最小的子数组)
5. [239. 滑动窗口最大值](239. 滑动窗口最大值)
6. *[395. 至少有 K 个重复字符的最长子串](395. 至少有 K 个重复字符的最长子串) 【2021-12-23】
7. [480. 滑动窗口中位数](480. 滑动窗口中位数)【难】【2021-12-24】
8. [567. 字符串的排列](./567. 字符串的排列)【2021-12-26】
9. [727. 最小窗口子序列](https://leetcode-cn.com/problems/minimum-window-subsequence)【Money】

### 2.5 流

1. [295. 数据流的中位数](295. 数据流的中位数)【难】【2021-12-27】【Redo】
2. [346. 数据流中的移动平均值](346. 数据流中的移动平均值)【Money】
3. [352. 将数据流变为多个不相交区间](352. 将数据流变为多个不相交区间)【2021-12-28】【Redo】
4. [703. 数据流中的第 K 大元素](703. 数据流中的第 K 大元素)【2021-12-28】

### 2.6 前项和

1. [53. 最大子数组和](53. 最大子数组和)【2021-12-29】【动态规划】【Redo】
   - 动态规划 (一维)
2. [238. 除自身以外数组的乘积](238. 除自身以外数组的乘积)【2021-12-29】
   - 前缀和 + 后缀和
3. [303. 区域和检索 - 数组不可变](303. 区域和检索 - 数组不可变)【2021-12-30】
   - 区间 = 前缀和(right) - 前缀和(left)
4. [325. 和等于 k 的最长子数组长](https://leetcode-cn.com/problems/maximum-size-subarray-sum-equals-k)【Money】
5. [528. 按权重随机选择](https://leetcode-cn.com/problems/random-pick-with-weight/)【2021-12-31】【Redo】【没理解】



## BFS

* `queue.offer()` 和 `visited = ture` 必须同时出现
* 层数 `level++` 在 `while` 和 `for(size)` 之间



## DFS (回溯)

* https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/
* 在 `backtracking` 时，进入下一层，是 `i + 1`，而**不是** `start + 1`
  * [78. 子集](./78. 子集)
  * [90. 子集 II](./90. 子集 II)

天龙八部

## 递归

* 构建树结构：
  * 找到根节点 **root**，根据各种关系找到其 **左子树 / 右子树 的范围**，递归构建
* [105. 从前序与中序遍历序列构造二叉树](105. 从前序与中序遍历序列构造二叉树)
* [108. 将有序数组转换为二叉搜索树](108. 将有序数组转换为二叉搜索树)

- 

## 条件二分法

- [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

### 同向双指针

```java
// 同向双指针
int j = 0;
for (int i = 0; i < n; i++) {
    // 不满⾜则循环到满⾜搭配为⽌
    while (j < n && i 到 j之间不满⾜条件){
        j += 1;
    }
    if (i 到 j之间满⾜条件){
        处理i，j这次搭配
    }
}
```

