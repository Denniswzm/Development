# 语法注意

- int -> double
  - `Double.valueOf(1)`
- 向上取整
  - `Math.ceil(7.0/3.0)`
  - 函数中必须是 Double 类型
- 除数为 (double) 0 时，不报错，但是会变为 2147483647
  - `int per = (int) Math.ceil(10.0 / (double) 0);`
- 打印数组
  - `System.out.println(Arrays.toString(nums));`
- 数组截取
  - `Arrays.copyOfRange(result, 0, index)`
- Collection 差集并集交集
  - java中交集使用 `A.retainAll(B)` ,交集的结果在集合A中。
  - 并集使用addAll，`A.addAll(B)` 因为set本身就去重，所有直接全部添加到一个集合中取并集。
  - 差集使用`removeAll`方法，去掉一集合中包含的另一个集合的值。`A.removeAll(B)`

# 题型分类

## BFS

* `queue.offer()` 和 `visited = ture` 必须同时出现
* 层数 `level++` 在 `while` 和 `for(size)` 之间



## DFS (回溯)

* https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/
* 在 `backtracking` 时，进入下一层，是 `i + 1`，而**不是** `start + 1`
  * [78. 子集](./78. 子集)
  * [90. 子集 II](./90. 子集 II)



## 递归

* 构建树结构：
  * 找到根节点 **root**，根据各种关系找到其 **左子树 / 右子树 的范围**，递归构建
* [105. 从前序与中序遍历序列构造二叉树](105. 从前序与中序遍历序列构造二叉树)
* [108. 将有序数组转换为二叉搜索树](108. 将有序数组转换为二叉搜索树)

## 双指针

### 朴素二分法：

- [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)
- [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)
- [154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)
- [658. 找到 K 个最接近的元素](https://leetcode-cn.com/problems/find-k-closest-elements/)
- $ [702.搜索长度未知的有序数组](https://leetcode-cn.com/problems/search-in-a-sorted-array-of-unknown-size)
- [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

## 条件二分法

- [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

### 同向双指针

```java
// 同向双指针
int j = 0;
for (int i = 0; i < n; i++) {
    // 不满⾜则循环到满⾜搭配为⽌
    while (j < n && i 到 j之间不满⾜条件){
        j += 1;
    }
    if (i 到 j之间满⾜条件){
        处理i，j这次搭配
    }
}
```

