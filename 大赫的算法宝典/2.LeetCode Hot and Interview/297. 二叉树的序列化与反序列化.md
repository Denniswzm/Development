#### [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

![image-20220102173142227](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220102173142227.png)

## 1. BFS

- ```java
  /**
   * Definition for a binary tree node.
   * public class TreeNode {
   *     int val;
   *     TreeNode left;
   *     TreeNode right;
   *     TreeNode(int x) { val = x; }
   * }
   */
  public class Codec {
  
      // Encodes a tree to a single string.
      public String serialize(TreeNode root) {
          // 1. 初始化
          StringBuilder sb = new StringBuilder();
          Queue<TreeNode> queue = new LinkedList<>();
  
          // 2. 向队列写入第一个值
          queue.offer(root);
  
          // 3. BFS
          while(!queue.isEmpty()){
              // 3.1 弹出队列第一个值
              TreeNode node = queue.poll();
              // 3.2 将其邻居加入队列
              // 节点不为空
              if(node != null){
                  sb.append(node.val);
                  queue.offer(node.left);
                  queue.offer(node.right);
              }
              // 节点为空
              else{
                  sb.append("#");
              }
  
              // 无论节点是否为空，都添加分隔符：逗号
              sb.append(",");
          }
          return sb.toString();
      }
  
      // Decodes your encoded data to tree.
      public TreeNode deserialize(String data) {
          // 1. 得到树节点
          String[] nodes = data.split(",");
  
          // 2. 如果数组头部就是 #，证明不存在该树
          if(nodes[0].equals("#")){
              return null;
          }
  
          // 3. Queue 记录每层的节点
          Queue<TreeNode> queue = new LinkedList<>();
          // 构建树结构
          TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));
          queue.offer(root);
  
          // 4. 遍历节点数组: nodes数组 -> Queue(TreeNode) -> 构建左右子树
          for(int i = 1; i < nodes.length; i++){
              // 4.1 去除当前节点
              TreeNode node = queue.poll();
  
              // 4.2 如果当前节点为空
              if(node == null){
                  continue;
              }
  
              // 4.3 左子树
              if(!nodes[i].equals("#")){
                  // 构建左子树
                  node.left = new TreeNode(Integer.parseInt(nodes[i]));
                  // 记录左子树，保证全局出现顺序不变
                  queue.offer(node.left);
  
              }
              // 遇见"#"，直接i++; 不遇见"#", 看nodes下一个数值
              i++;
  
              // 4.4 右子树
              if(!nodes[i].equals("#")){
                  node.right = new TreeNode(Integer.parseInt(nodes[i]));
                  queue.offer(node.right);
              }
              // for 循环隐藏 i++
          }
          return root;
      }
  }
  
  // Your Codec object will be instantiated and called as such:
  // Codec ser = new Codec();
  // Codec deser = new Codec();
  // TreeNode ans = deser.deserialize(ser.serialize(root));
  ```

- 