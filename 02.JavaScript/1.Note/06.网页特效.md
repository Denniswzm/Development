

# 1. 元素偏移量 offset 系列

## 1.1 offset 概述

`offset` 翻译过来就是偏移量， 我们使用 offset 系列相关属性可以动态的得到`该元素的位置（偏移）`、`大小`等。

- 获得 **元素距离** 带有 **定位父元素** 的位置
- 获得元素**自身的大小**（宽度高度）
- 注意： 返回的数值都**不带单位**

offset 系列常用属性：

- ![image-20220108231301552](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220108231301552.png)

- ![image-20220109163100042](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220109163100042.png)

- ```html
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
      <style>
          * {
              margin: 0;
              padding: 0;
          }
          
          .father {
              /* position: relative; */
              width: 200px;
              height: 200px;
              background-color: pink;
              margin: 150px;
          }
          
          .son {
              width: 100px;
              height: 100px;
              background-color: purple;
              margin-left: 45px;
          }
          
          .w {
              height: 200px;
              background-color: skyblue;
              margin: 0 auto 200px;
              padding: 10px;
              border: 15px solid red;
          }
      </style>
  </head>
  
  <body>
      <div class="father">
          <div class="son"></div>
      </div>
      <div class="w"></div>
      
      <script>
          // offset 系列
          var father = document.querySelector('.father');
          var son = document.querySelector('.son');
          
          // 1.可以得到元素的偏移 位置 返回的不带单位的数值  
          console.log(father.offsetTop);
          console.log(father.offsetLeft);
          
          // 它以带有定位的父亲为准（150px），如果么有父亲或者父亲没有定位，则以 body 自身为准（195px）
          console.log(son.offsetLeft);
          
          // 获取 w 元素
          var w = document.querySelector('.w');
          
          // 2.可以得到元素的大小，宽度和高度，是包含 padding + border + width 
          console.log(w.offsetWidth);
          console.log(w.offsetHeight);
          
          // 3. 返回带有定位的父亲 否则返回的是body
          console.log(son.offsetParent); // 返回带有【定位】的父亲, 否则返回的是body
          console.log(son.parentNode); // 返回父亲, 是最近一级的父亲, 亲爸爸; 不管父亲有没有定位
      </script>
  </body>
  ```

- ![image-20220108233739665](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220108233739665.png)

## 1.2 offset 与 style 区别

- ![image-20220109162334050](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220109162334050.png)
- offset 只读属性，不可改变
- style 可读写，可赋值

### # 案例：获取鼠标在盒子内的坐标

① 我们在盒子内点击，想要得到鼠标距离盒子左右的距离。
② 首先得到鼠标在页面中的坐标（`e.pageX`, `e.pageY`）
③ 其次得到盒子在页面中的距离 ( `box.offsetLeft`, `box.offsetTop`)
④ 用鼠标距离页面的坐标减去盒子在页面中的距离，得到 鼠标在盒子内的坐标
⑤ 如果想要移动一下鼠标，就要获取最新的坐标，使用鼠标移动事件 mousemove

- ```html
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
      <style>
          .box {
              width: 300px;
              height: 300px;
              background-color: pink;
              margin: 200px;
          }
      </style>
  </head>
  
  <body>
      <div class="box"></div>
      <script>
          // 我们在盒子内点击， 想要得到鼠标距离盒子左右的距离。
          // 首先得到鼠标在页面中的坐标（ e.pageX, e.pageY）
          // 其次得到盒子在页面中的距离(box.offsetLeft, box.offsetTop)
          // 用鼠标距离页面的坐标减去盒子在页面中的距离， 得到 鼠标在盒子内的坐标
          var box = document.querySelector('.box');
          box.addEventListener('mousemove', function(e) {
              // console.log(e.pageX);
              // console.log(e.pageY);
              // console.log(box.offsetLeft);
              var x = e.pageX - this.offsetLeft;
              var y = e.pageY - this.offsetTop;
              this.innerHTML = 'x坐标是' + x + ' y坐标是' + y;
          })
      </script>
  </body>
  ```

- 

- ![image-20220109163242040](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220109163242040.png)



### # 案例：模态框拖拽

弹出框，我们也称为模态框。
1. 点击弹出层， 会弹出模态框， 并且显示灰色半透明的遮挡层。
2. 点击关闭按钮，可以关闭模态框，并且同时关闭灰色半透明遮挡层。
3. 鼠标放到模态框最上面一行，可以按住鼠标拖拽模态框在页面中移动。
4. 鼠标松开，可以停止拖动模态框移动。

案例分析

- ① 点击弹出层， 模态框和遮挡层就会显示出来 display:block;
- ② 点击关闭按钮，模态框和遮挡层就会隐藏起来 display:none;
- ③ 在页面中拖拽的原理： 鼠标按下并且移动， 之后松开鼠标
- ④ 触发事件是鼠标按下 `mousedown`， 鼠标移动`mousemove` 鼠标松开 `mouseup`
- ⑤ 拖拽过程: 鼠标移动过程中，获得最新的值赋值给模态框的left和top值， 这样模态框可以跟着鼠标走了
- ⑥ 鼠标按下触发的事件源是 最上面一行，就是 id 为 title
- ⑦ 鼠标的坐标 减去 鼠标在盒子内的坐标， 才是模态框真正的位置。
- ⑧ 鼠标按下，我们要得到鼠标在盒子的坐标。
- ⑨ 鼠标移动，就让模态框的坐标 设置为 ： 鼠标坐标 减去盒子坐标即可，注意移动事件写到按下事件里面。
- ⑩ 鼠标松开，就停止拖拽，就是可以让鼠标移动事件解除

- ```html
  <head lang="en">
      <meta charset="UTF-8">
      <title></title>
      <style>
          .login-header {
              width: 100%;
              text-align: center;
              height: 30px;
              font-size: 24px;
              line-height: 30px;
          }
  
          ul,
          li,
          ol,
          dl,
          dt,
          dd,
          div,
          p,
          span,
          h1,
          h2,
          h3,
          h4,
          h5,
          h6,
          a {
              padding: 0px;
              margin: 0px;
          }
  
          .login {
              display: none;
              width: 512px;
              height: 280px;
              position: fixed;
              border: #ebebeb solid 1px;
              left: 50%;
              top: 50%;
              background: #ffffff;
              box-shadow: 0px 0px 20px #ddd;
              z-index: 9999;
              transform: translate(-50%, -50%);
          }
  
          .login-title {
              width: 100%;
              margin: 10px 0px 0px 0px;
              text-align: center;
              line-height: 40px;
              height: 40px;
              font-size: 18px;
              position: relative;
              cursor: move;
          }
  
          .login-input-content {
              margin-top: 20px;
          }
  
          .login-button {
              width: 50%;
              margin: 30px auto 0px auto;
              line-height: 40px;
              font-size: 14px;
              border: #ebebeb 1px solid;
              text-align: center;
          }
  
          .login-bg {
              display: none;
              width: 100%;
              height: 100%;
              position: fixed;
              top: 0px;
              left: 0px;
              background: rgba(0, 0, 0, .3);
          }
  
          a {
              text-decoration: none;
              color: #000000;
          }
  
          .login-button a {
              display: block;
          }
  
          .login-input input.list-input {
              float: left;
              line-height: 35px;
              height: 35px;
              width: 350px;
              border: #ebebeb 1px solid;
              text-indent: 5px;
          }
  
          .login-input {
              overflow: hidden;
              margin: 0px 0px 20px 0px;
          }
  
          .login-input label {
              float: left;
              width: 90px;
              padding-right: 10px;
              text-align: right;
              line-height: 35px;
              height: 35px;
              font-size: 14px;
          }
  
          .login-title span {
              position: absolute;
              font-size: 12px;
              right: -20px;
              top: -30px;
              background: #ffffff;
              border: #ebebeb solid 1px;
              width: 40px;
              height: 40px;
              border-radius: 20px;
          }
      </style>
  </head>
  
  <body>
      <!-- header -->
      <div class="login-header"><a id="link" href="javascript:;">点击，弹出登录框</a></div>
      <!-- login 模块 -->
      <div id="login" class="login">
          <div id="title" class="login-title">登录会员
              <span><a id="closeBtn" href="javascript:void(0);" class="close-login">关闭</a></span>
          </div>
          <div class="login-input-content">
              <div class="login-input">
                  <label>用户名：</label>
                  <input type="text" placeholder="请输入用户名" name="info[username]" id="username" class="list-input">
              </div>
              <div class="login-input">
                  <label>登录密码：</label>
                  <input type="password" placeholder="请输入登录密码" name="info[password]" id="password" class="list-input">
              </div>
          </div>
          <div id="loginBtn" class="login-button"><a href="javascript:void(0);" id="login-button-submit">登录会员</a></div>
      </div>
      <!-- 遮盖层 -->
      <div id="bg" class="login-bg"></div>
  
      <script>
          // 1. 获取元素
          var login = document.querySelector('.login');
          var mask = document.querySelector('.login-bg');
          var link = document.querySelector('#link');
          var closeBtn = document.querySelector('#closeBtn');
          var title = document.querySelector('#title');
          // 2. 点击弹出层这个链接 link  让mask 和login 显示出来
          link.addEventListener('click', function() {
              mask.style.display = 'block';
              login.style.display = 'block';
          })
          // 3. 点击 closeBtn 就隐藏 mask 和 login 
          closeBtn.addEventListener('click', function() {
              mask.style.display = 'none';
              login.style.display = 'none';
          })
          // 4. 开始拖拽
          // (1) 当我们鼠标按下， 就获得鼠标在盒子内的坐标
          title.addEventListener('mousedown', function(e) {
              // 鼠标到盒子边框的距离：不变
              var x = e.pageX - login.offsetLeft;
              var y = e.pageY - login.offsetTop;
              // (2) 鼠标移动的时候，把鼠标在页面中的坐标，减去 鼠标在盒子内的坐标就是模态框的left和top值
              document.addEventListener('mousemove', move)
  			// 起名字，方便删除
              // 必须通过 style 赋值
              function move(e) {
                  login.style.left = e.pageX - x + 'px';
                  login.style.top = e.pageY - y + 'px';
              }
              // (3) 鼠标弹起，就让鼠标移动事件移除
              document.addEventListener('mouseup', function() {
                  document.removeEventListener('mousemove', move);
              })
          })
      </script>
  </body>
  ```
  
- ![image-20220109172211396](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220109172211396.png)



### # 仿京东放大镜

- ① 整个案例可以分为三个功能模块

- ② 鼠标经过小图片盒子， 黄色的遮挡层 和 大图片盒子显示，离开隐藏2个盒子功能

- ③ 黄色的遮挡层跟随鼠标功能。

- ④ 移动黄色遮挡层，大图片跟随移动功能。

- ![image-20220110114502738](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110114502738.png)

- ```css
  .preview_img {
      position: relative;
      height: 398px;
      border: 1px solid #ccc;
  }
  
  .mask {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 300px;
      height: 300px;
      background: #FEDE4F;
      opacity: .5;
      border: 1px solid #ccc;
      cursor: move;
  }
  
  .big {
      display: none;
      position: absolute;
      left: 410px;
      top: 0;
      width: 500px;
      height: 500px;
      background-color: pink;
      z-index: 999;
      border: 1px solid #ccc;
      overflow: hidden;
  }
  
  .big img {
      position: absolute;
      top: 0;
      left: 0;
  }
  ```

- ```js
  window.addEventListener('load', function() {
      var preview_img = document.querySelector('.preview_img');
      var mask = document.querySelector('.mask');
      var big = document.querySelector('.big');
      
      // 1. 当我们鼠标经过 preview_img 就显示和隐藏 mask 遮挡层 和 big 大盒子
      // 显示
      preview_img.addEventListener('mouseover', function() {
          mask.style.display = 'block';
          big.style.display = 'block';
      })
      // 隐藏
      preview_img.addEventListener('mouseout', function() {
          mask.style.display = 'none';
          big.style.display = 'none';
      })
      
      // 2. 鼠标移动的时候，让黄色的盒子跟着鼠标来走
      preview_img.addEventListener('mousemove', function(e) {
          // (1). 先计算出鼠标在盒子内的坐标
          var x = e.pageX - this.offsetLeft;
          var y = e.pageY - this.offsetTop;
          
          // (2) 减去盒子高度 300的一半 是 150 就是我们mask 的最终 left 和top值了
          
          // (3) 需要 mask 移动的距离（向上一半，向左一半）
          var maskX = x - mask.offsetWidth / 2;
          var maskY = y - mask.offsetHeight / 2;
          
          // (4) 如果 x 坐标小于了0, 就让他停在 0 的位置
          // 遮挡层的最大移动距离 (左边距离)
          var maskMax = preview_img.offsetWidth - mask.offsetWidth;
          // x 轴
          if (maskX <= 0) {
              maskX = 0;
          } else if (maskX >= maskMax) {
              maskX = maskMax;
          }
          // y 轴
          if (maskY <= 0) {
              maskY = 0;
          } else if (maskY >= maskMax) {
              maskY = maskMax;
          }
          
          mask.style.left = maskX + 'px';
          mask.style.top = maskY + 'px';
          
          // 3. 大图片的移动距离 = 遮挡层移动距离 * 大图片最大移动距离 / 遮挡层的最大移动距离
          // 大图
          var bigIMg = document.querySelector('.bigImg');
          
          // 大图片最大移动距离
          var bigMax = bigIMg.offsetWidth - big.offsetWidth;
          
          // 大图片的移动距离 X Y
          var bigX = maskX * bigMax / maskMax;
          var bigY = maskY * bigMax / maskMax;
          
          bigIMg.style.left = -bigX + 'px';
          bigIMg.style.top = -bigY + 'px';
      })
  })
  ```

# 2. 元素可视区 client 系列

- client 翻译过来就是客户端，我们使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client 系列的相关属性可以动态的得到该元素的`边框大小`、`元素大小`等，`不含边框 (border)`，`包含 padding`
- ![image-20220110135352051](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110135352051.png)
- ![image-20220110135425088](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110135425088.png)

### # 案例： 淘宝 flexible.js 源码分析

下面三种情况都会刷新页面都会触发 load 事件

1. a标签的超链接
2. F5或者刷新按钮（强制刷新）
3. 前进后退按钮

- ![image-20220110142529803](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110142529803.png)

### * 立即执行函数 `(function(param1, param2) {})(param1, param2)` 或者 `(function(){}())`

- 立即执行函数最大的作用就是：**独立创建了一个作用域**, 里面所有的变量都是**局部变量**，不会有**命名冲突**的情况

- ```js
  <body>
      <script>
          // 1.立即执行函数: 不需要调用，立马能够自己执行的函数
          function fn() {
              console.log(1);
          }
          fn();
          // 2. 写法 也可以传递参数进来
          // 1.(function() {})()    或者  2. (function(){}());
          (function(a, b) {
              console.log(a + b);
              var num = 10;
          })(1, 2); // 第二个小括号可以看做是调用函数
          (function sum(a, b) {
              console.log(a + b);
              var num = 10; // 局部变量
          }(2, 3));
          // 3. 立即执行函数最大的作用就是 独立创建了一个作用域, 里面所有的变量都是局部变量 不会有命名冲突的情况
      </script>
  </body>
  ```

# 3. 元素滚动 scroll 系列

## 3.1 元素 scroll 系列属性

- scroll 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该`元素的大小`、`滚动距离`等。
  - 不包含边框 (border)
  - 包含 padding
  - 得到 **内容实际大小**
- ![image-20220110150156659](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110150156659.png)
- ![image-20220110150313678](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110150313678.png)

## 3.2 页面被卷去的头部

- 如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，我们就称为页面被卷去的头部。**滚动条在滚动时**会触发 `onscroll` 事件。

### # 案例：滚动侧边栏

1. 需要用到页面滚动事件 `scroll` 因为是页面滚动，所以事件源是 document
2. 滚动到某个位置，就是判断页面被卷去的上部值。
3. 页面被卷去的头部：可以通过`window.pageYOffset` 获得 如果是被卷去的左侧 `window.pageXOffset`
4. 注意，元素被卷去的头部是 `element.scrollTop` , 如果是页面被卷去的头部 则是 `window.pageYOffset`
5. 其实这个值 可以通过盒子的 `offsetTop` 可以得到，如果大于等于这个值，就可以让盒子固定定位了

- ```html
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
      <style>
          .slider-bar {
              position: absolute;
              left: 50%;
              top: 300px;
              margin-left: 600px;
              width: 45px;
              height: 130px;
              background-color: pink;
          }
  
          .w {
              width: 1200px;
              margin: 10px auto;
          }
  
          .header {
              height: 150px;
              background-color: purple;
          }
  
          .banner {
              height: 250px;
              background-color: skyblue;
          }
  
          .main {
              height: 1000px;
              background-color: yellowgreen;
          }
  
          span {
              display: none;
              position: absolute;
              bottom: 0;
          }
      </style>
  </head>
  
  <body>
      <div class="slider-bar">
          <span class="goBack">返回顶部</span>
      </div>
      <div class="header w">头部区域</div>
      <div class="banner w">banner区域</div>
      <div class="main w">主体部分</div>
      <script>
          //1. 获取元素
          var sliderbar = document.querySelector('.slider-bar');
          var banner = document.querySelector('.banner');
          // banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面
          var bannerTop = banner.offsetTop
          // 当我们侧边栏固定定位之后应该变化的数值
          var sliderbarTop = sliderbar.offsetTop - bannerTop;
          // 获取main 主体元素
          var main = document.querySelector('.main');
          var goBack = document.querySelector('.goBack');
          var mainTop = main.offsetTop;
          // 2. 页面滚动事件 scroll
          document.addEventListener('scroll', function() {
              // window.pageYOffset 页面被卷去的头部
              // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位
              if (window.pageYOffset >= bannerTop) {
                  sliderbar.style.position = 'fixed';
                  sliderbar.style.top = sliderbarTop + 'px';
              } else {
                  sliderbar.style.position = 'absolute';
                  sliderbar.style.top = '300px';
              }
              // 4. 当我们页面滚动到main盒子，就显示 goback模块
              if (window.pageYOffset >= mainTop) {
                  goBack.style.display = 'block';
              } else {
                  goBack.style.display = 'none';
              }
  
          })
      </script>
  </body>
  ```

## 3.3 页面被卷去的头部兼容性解决方案

需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法：

1. 声明了 DTD，使用 `document.documentElement.scrollTop`
2. 未声明 DTD，使用 `document.body.scrollTop`
3. 新方法 `window.pageYOffset` 和 `window.pageXOffset`，IE9 开始支持

- ```js
  function getScroll() {
      return {
          left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft||0,
          top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
      };
  }
  ```

# 三大系列总结

- 他们主要用法：
  1. `offset`系列 经常用于获得元素位置 `offsetLeft`, `offsetTop`
  2. `client` 经常用于获取元素大小 `clientWidth`, `clientHeight`
  3. `scroll` 经常用于获取滚动距离 `scrollTop`, `scrollLeft`
  4. 注意页面滚动的距离通过 `window.pageXOffset` 获得
- ![image-20220110160053998](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110160053998.png)

- ![image-20220110160058674](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110160058674.png)
- ![image-20220110160114838](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110160114838.png)
- ![image-20220110160134272](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110160134272.png)



# *. mouseenter 和mouseover的区别

## *.1 mouseenter 鼠标事件

- 当鼠标移动到元素上时就会触发 `mouseenter` 事件
- 类似 `mouseover`，它们两者之间的差别是
- `mouseover` 鼠标 **经过自身盒子** 会触发，**经过子盒子** 还会触发。 `mouseenter` 只会 **经过自身盒子** 触发
- 之所以这样，就是因为`mouseenter`不会冒泡。 mouseover 进入内部子盒子后，会冒泡到外部盒子
- 跟`mouseenter`搭配 鼠标离开 `mouseleave` 同样不会冒泡

# 4. 动画函数封装

## 4.1 动画实现原理

- **核心原理**：通过定时器 `setInterval()` 不断移动盒子位置。

### 实现步骤：

- 获得盒子当前位置
- 让盒子在当前位置加上1个移动距离
- 利用定时器不断重复这个操作
- 加一个结束定时器的条件
- 注意此元素需要 **添加定位**，才能使用`element.style.left`

## 4.2 动画函数简单封装

- ```html
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
      <style>
          div {
              position: absolute;
              left: 0;
              width: 100px;
              height: 100px;
              background-color: pink;
          }
          
          span {
              position: absolute;
              left: 0;
              top: 200px;
              display: block;
              width: 150px;
              height: 150px;
              background-color: purple;
          }
      </style>
  </head>
  
  <body>
      <div></div>
      <span>夏雨荷</span>
      <script>
          // 简单动画函数封装obj目标对象 target 目标位置
          function animate(obj, target) {
              var timer = setInterval(function() {
                  if (obj.offsetLeft >= target) {
                      // 停止动画 本质是停止定时器
                      clearInterval(timer);
                  }
                  obj.style.left = obj.offsetLeft + 1 + 'px';
  
              }, 30);
          }
  
          var div = document.querySelector('div');
          var span = document.querySelector('span');
          // 调用函数
          animate(div, 300);
          animate(span, 200);
      </script>
  </body>
  ```

- ![image-20220110165933859](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110165933859.png)

## 

## 4.3 动画函数给不同元素记录不同定时器

- 如果多个元素都使用这个动画函数，每次都要 var 声明定时器。我们可以**给不同的元素使用不同的定时器**（自
  己专门用自己的定时器）。

- **核心原理**：利用 JS 是一门动态语言，可以很方便的给当前对象添加属性。

- ```html
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
      <style>
          div {
              position: absolute;
              left: 0;
              width: 100px;
              height: 100px;
              background-color: pink;
          }
  
          span {
              position: absolute;
              left: 0;
              top: 200px;
              display: block;
              width: 150px;
              height: 150px;
              background-color: purple;
          }
      </style>
  </head>
  
  <body>
      <button>点击夏雨荷才走</button>
      <div></div>
      <span>夏雨荷</span>
      <script>
          // var obj = {};
          // obj.name = 'andy';
          // 简单动画函数封装obj目标对象 target 目标位置
          // 给不同的元素指定了不同的定时器
          function animate(obj, target) {
              // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器
              // 解决方案就是 让我们元素只有一个定时器执行
              // 先清除以前的定时器，只保留当前的一个定时器执行
              clearInterval(obj.timer);
              obj.timer = setInterval(function() {
                  if (obj.offsetLeft >= target) {
                      // 停止动画 本质是停止定时器
                      clearInterval(obj.timer);
                  }
                  obj.style.left = obj.offsetLeft + 1 + 'px';
  
              }, 30);
          }
  
          var div = document.querySelector('div');
          var span = document.querySelector('span');
          var btn = document.querySelector('button');
          // 调用函数
          animate(div, 300);
          btn.addEventListener('click', function() {
              animate(span, 200);
          })
      </script>
  </body>
  ```

- 









































































